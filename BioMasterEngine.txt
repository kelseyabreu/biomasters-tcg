---

### Part 1: The Card Data Pipeline

These three JSON files represent the "mind" of the game. They are completely separate from the engine code and can be edited by a game designer to create, balance, and translate the game.

#### `en.json` (The English Language "Skin")

This file provides all the human-readable text. Translating the game is as simple as creating a `es.json`, `fr.json`, etc., with the same structure.

```json
{
  "CardNames": {
    "1": "Oak Tree",
    "2": "Kelp Forest",
    "3": "Riverbank",
    "4": "Field Rabbit",
    "5": "Sockeye Salmon",
    "6": "Grizzly Bear",
    "7": "Great White Shark",
    "8": "Mycena Mushroom",
    "9": "Vulture",
    "10": "Deer Tick"
  },
  "CardAbilitiesText": {
    "1": "[WATERSHED PREDATOR] (Action): Exhaust this card. Target one [AQUATIC] creature adjacent to an [AMPHIBIOUS] card that this Bear is also adjacent to. Exhaust that target.",
    "2": "[APEX PREDATOR] (Action): Exhaust this card. Target an adjacent +3C or +4C creature. It becomes Exhausted.",
    "3": "[SCAVENGE] (Action): Exhaust this card. Take one creature card from the Detritus Zone and put it into your hand.",
    "4": "[PARASITIC DRAIN] (Persistent): The host creature does not Ready during its owner's Ready Phase.",
    "5": "[RECYCLER] (Action): Exhaust this card. Place the card underneath the adjacent -1S card into your score pile. It is worth its printed VP +1. Then, draw a card."
  },
  "Keywords": {
    "1": "Terrestrial",
    "2": "Aquatic",
    "3": "Amphibious",
    "4": "Freshwater",
    "5": "Marine",
    "6": "Forest",
    "7": "River",
    "8": "Ocean",
    "9": "Fish",
    "10": "Mammal",
    "11": "Pack Hunter",
    "12": "Venomous",
    "13": "Scavenge",
    "14": "Hypercarnivore",
    "15": "Watershed Predator"
  },
  "TrophicCategories": {
    "1": "Photoautotroph",
    "3": "Herbivore",
    "4": "Omnivore",
    "5": "Carnivore",
    "7": "Saprotroph",
    "9": "Parasite"
  }
}
```

---

#### `abilities.json` (The Logic Blueprint)

This file describes *what* abilities do, using a library of generic effects. The engine reads this to execute actions.

```json
[
  {
    "AbilityID": 1,
    "TriggerID": 1, 
    "Effects": [
      {
        "EffectID": 1,
        "SelectorID": 5, 
        "FilterKeywords": [2],
        "ActionID": 2
      }
    ]
  },
  {
    "AbilityID": 2,
    "TriggerID": 1,
    "Effects": [
      {
        "EffectID": 1,
        "SelectorID": 1,
        "FilterTrophicCategories": [5],
        "FilterTrophicLevels": [3, 4],
        "ActionID": 2
      }
    ]
  },
  {
    "AbilityID": 3,
    "TriggerID": 1,
    "Effects": [
      {
        "EffectID": 3,
        "SelectorID": 6, 
        "ActionID": 4
      }
    ]
  },
  {
    "AbilityID": 4,
    "TriggerID": 2,
    "Effects": [
      {
        "EffectID": 4, 
        "SelectorID": 7, 
        "ActionID": 5 
      }
    ]
  }
]
```
**ID Key:**
*   **TriggerID:** `1`=ON_ACTIVATE, `2`=PERSISTENT_ATTACHED
*   **EffectID:** `1`=TARGET, `2`=... , `3`=TAKE_CARD, `4`=APPLY_STATUS
*   **SelectorID:** `1`=ADJACENT, `5`=ADJACENT_TO_SHARED_AMPHIBIOUS, `6`=CARD_IN_DETRITUS_ZONE, `7`=SELF_HOST
*   **ActionID:** `1`=..., `2`=EXHAUST_TARGET, `3`=..., `4`=MOVE_TO_HAND, `5`=PREVENT_READY

---

#### `cards.json` (The Core Card Database)

This is the central definition of every card, using only universal IDs.

```json
[
  {
    "CardID": 1,
    "TrophicLevel": 1,
    "TrophicCategory": 1,
    "Cost": null,
    "Keywords": [1, 6] 
  },
  {
    "CardID": 4,
    "TrophicLevel": 2,
    "TrophicCategory": 3,
    "Cost": { "Requires": [{"Category": 1, "Count": 1}] },
    "Keywords": [1] 
  },
  {
    "CardID": 6,
    "TrophicLevel": 3,
    "TrophicCategory": 4,
    "Cost": { "Requires": [{"Category": 3, "Count": 2}] },
    "Keywords": [1, 10, 15], 
    "Abilities": [1]
  },
  {
    "CardID": 7,
    "TrophicLevel": 4,
    "TrophicCategory": 5,
    "Cost": { "Requires": [{"Category": 5, "Count": 2, "Level": 3}] },
    "Keywords": [2, 5, 9, 14],
    "Abilities": [2]
  },
  {
    "CardID": 9,
    "TrophicLevel": 3,
    "TrophicCategory": 5, 
    "Cost": { "Requires": [{"Category": 3, "Count": 1}] },
    "Keywords": [1, 13], 
    "Abilities": [3] 
  },
  {
    "CardID": 10,
    "TrophicLevel": null,
    "TrophicCategory": 9, 
    "Cost": { "Requires": [{"Category": 1, "Count": 1}] },
    "Keywords": [],
    "Abilities": [4]
  }
]
```

---

### Part 2: The Game Engine (Conceptual TypeScript/JavaScript Outline)

This is the "soul" of the game. It is a state machine that knows nothing about specific cards, only how to process the data from the JSON files.

```typescript
// --- TYPE DEFINITIONS (Generated by Kysely from the DB) ---
// Interfaces for CardData, AbilityData, EffectData, etc.

// --- MAIN GAME ENGINE CLASS ---
class BioMastersEngine {
    private gameState: GameState;
    private cardDatabase: Map<number, CardData>;
    private abilityDatabase: Map<number, AbilityData>;

    constructor(cardData: CardData[], abilityData: AbilityData[]) {
        this.cardDatabase = new Map(cardData.map(c => [c.cardId, c]));
        this.abilityDatabase = new Map(abilityData.map(a => [a.abilityID, a]));
        this.gameState = this.initializeNewGame(2); // e.g., for 2 players
    }

    // --- CORE ACTION PROCESSOR ---
    // This is the single entry point for all player actions.
    public processAction(action: PlayerAction): { isValid: boolean, newState: GameState } {
        switch (action.type) {
            case 'PLAY_CARD':
                return this.handlePlayCard(action.payload);
            case 'ACTIVATE_ABILITY':
                return this.handleActivateAbility(action.payload);
            // ... other action types
            default:
                return { isValid: false, newState: this.gameState };
        }
    }

    // --- HANDLER FOR PLAYING A CARD ---
    private handlePlayCard(payload: PlayCardPayload): { isValid: boolean, newState: GameState } {
        const { playerID, cardID, position, connectionTargetID } = payload;
        const cardToPlay = this.cardDatabase.get(cardID);
        const targetCard = this.gameState.grid.get(connectionTargetID);

        // 1. VALIDATION CHECKS
        // Is the card in the player's hand?
        // Is the position valid?
        // Domain Rule Check: Use a helper function `Validator.isDomainLegal(cardToPlay, targetCard)`
        // Trophic Rule Check: `Validator.isTrophicLegal(cardToPlay, targetCard)`
        // Cost Check: `Validator.canAffordCost(playerID, cardToPlay.cost, this.gameState)`

        if (!allChecksPass) {
            return { isValid: false, newState: this.gameState };
        }

        // 2. STATE MUTATION
        // Create a deep copy of the gameState to maintain immutability
        const newState = JSON.parse(JSON.stringify(this.gameState));
        
        // Pay the cost (find and exhaust the required cards)
        newState.players[playerID].gridCards = this.payCost(newState.players[playerID].gridCards, cardToPlay.cost);
        
        // Place the new card on the grid
        const newInstanceID = generateUniqueInstanceID(); // An instance ID is crucial for targeting
        newState.grid.set(position, { instanceID: newInstanceID, cardID: cardID, ownerID: playerID, isExhausted: true }); // Enters exhausted by default

        // 3. SYNERGY CHECK (Preferred Diet)
        // Check for "Preferred Diet" conditions and if met, set `isExhausted: false` on the new card
        // NOTE: All producers (+1) including both Photoautotrophs and Chemoautotrophs can connect to HOME
        // HOME cards represent geological foundations supporting both photosynthetic and chemosynthetic life
        
        this.gameState = newState;
        return { isValid: true, newState: this.gameState };
    }

    // --- HANDLER FOR ACTIVATING AN ABILITY ---
    private handleActivateAbility(payload: ActivateAbilityPayload): { isValid: boolean, newState: GameState } {
        const { playerID, instanceID, abilityID, targetInstanceID } = payload;
        const ability = this.abilityDatabase.get(abilityID);
        const actingCard = this.gameState.grid.find(c => c.instanceID === instanceID);

        // VALIDATION: Is the card ready? Is it the correct player?

        // Execute the effect chain defined in abilities.json
        const newState = this.executeEffects(ability.effects, { actingCard, targetCard, gameState: this.gameState });

        this.gameState = newState;
        return { isValid: true, newState: this.gameState };
    }

    // --- EFFECT EXECUTION SYSTEM ---
    private executeEffects(effects: EffectData[], context: EffectContext): GameState {
        let tempState = JSON.parse(JSON.stringify(context.gameState));
        
        for (const effect of effects) {
            // The Selector finds valid targets based on the SelectorID (e.g., ADJACENT)
            const targets = SelectorSystem.findTargets(effect.SelectorID, context, tempState);

            // The Action System performs the action (e.g., EXHAUST_TARGET) on the targets
            tempState = ActionSystem.performAction(effect.ActionID, targets, tempState);
        }
        
        return tempState;
    }

    // ... other methods for initialization, state management, etc.
}

// --- SUB-SYSTEMS ---
// These are pure functions that operate on the game state.

class Validator {
    static isDomainLegal(cardA, cardB): boolean { /* ... */ }
    static isTrophicLegal(cardA, cardB): boolean { /* ... */ }
    static canAffordCost(playerID, cost, state): boolean { /* ... */ }
}

class SelectorSystem {
    static findTargets(selectorID, context, state): Target[] {
        // Switch statement for each SelectorID (ADJACENT, ADJACENT_TO_SHARED_AMPHIBIOUS, etc.)
        // Returns an array of valid targets.
    }
}

class ActionSystem {
    static performAction(actionID, targets, state): GameState {
        // Switch statement for each ActionID (EXHAUST_TARGET, MOVE_TO_HAND, etc.)
        // Returns the mutated game state.
    }
}

```


II. Database Schema (PostgreSQL)
We will use a relational model to ensure data integrity. All tables will use integer IDs as primary keys.
keywords Table
id (PK, Integer)
keyword_name (Text, e.g., "AQUATIC", "SCAVENGE") - Internal use only
cards Table (The Card "Blueprint")
id (PK, Integer) - This is the universal CardID
trophic_level (Integer)
trophic_category_id (Integer, FK to trophic_categories.id)
Other static properties as needed (e.g., base VP)
card_keywords Table (Many-to-Many Join)
card_id (Integer, FK to cards.id)
keyword_id (Integer, FK to keywords.id)
abilities Table
id (PK, Integer)
trigger_id (Integer, FK to triggers.id)
effect_json (JSONB) - A flexible field to store the chain of effects (e.g., [{ "EffectID": 1, "SelectorID": 5, ...}])
card_abilities Table (Many-to-Many Join)
card_id (Integer, FK to cards.id)
ability_id (Integer, FK to abilities.id)
users Table
id (PK, UUID)
firebase_uid (Text, Unique)
email (Text)
is_guest (Boolean)
created_at (Timestamp)
user_decks and user_collections Tables
Standard tables to link users.id to cards.id, tracking player collections and saved deck lists.




This architecture is the professional standard for a reason. It is robust, scalable, and beautifully separates the concerns of game design, programming, and translation. It provides a solid foundation upon which the entire **BioMasters TCG** digital experience can be built.