🌐 BIOMASTERS TCG - WEBSOCKET, REDIS & REAL-TIME ARCHITECTURE FLOW
═══════════════════════════════════════════════════════════════════

📱 CLIENT-SERVER COMMUNICATION PATTERNS
═══════════════════════════════════════

1. WEBSOCKET CONNECTION ESTABLISHMENT
   ┌─────────────┐    WebSocket     ┌─────────────┐
   │   Client    │ ────────────────► │   Server    │
   │ (React App) │                  │ (Socket.IO) │
   └─────────────┘                  └─────────────┘
        │                                  │
        │ 1. socket.connect()              │
        │ ──────────────────────────────► │
        │                                  │ 2. Authenticate token
        │                                  │ ──────────────────►
        │                                  │
        │ 3. 'connection' event            │
        │ ◄────────────────────────────── │
        │                                  │
        │ 4. Join personal room            │
        │    socket.join(`user:${userId}`) │
        │ ◄────────────────────────────── │

2. REAL-TIME EVENT FLOW
   Client Events → Server:
   ┌─────────────────────────────────────────────────────────┐
   │ • 'find_match'     → Queue for matchmaking             │
   │ • 'join_session'   → Join game session                 │
   │ • 'game_action'    → Send game move/action             │
   │ • 'leave_session'  → Leave current game                │
   │ • 'cancel_search'  → Cancel matchmaking                │
   └─────────────────────────────────────────────────────────┘

   Server Events → Client:
   ┌─────────────────────────────────────────────────────────┐
   │ • 'match_found'      → Match ready, join session       │
   │ • 'game_state'       → Current game state              │
   │ • 'game_state_update'→ Real-time state changes         │
   │ • 'player_joined'    → Another player joined           │
   │ • 'turn_timer'       → Turn countdown timer            │
   │ • 'error'            → Error messages                  │
   └─────────────────────────────────────────────────────────┘

🔴 REDIS ARCHITECTURE & USAGE
═════════════════════════════

1. REDIS AS KEY-VALUE STORE
   ┌─────────────────────────────────────────────────────────┐
   │ Key Pattern                │ Value                      │
   ├────────────────────────────┼────────────────────────────┤
   │ session:{sessionId}        │ Complete game state JSON   │
   │ user:{userId}:session      │ Current session ID         │
   │ session:{id}:turn_timer    │ Turn timer data            │
   │ queue:{gameMode}           │ Sorted set of players      │
   │ player:{id}:reserved       │ Reservation lock           │
   └─────────────────────────────────────────────────────────┘

2. REDIS PUB/SUB CHANNELS
   ┌─────────────────────────────────────────────────────────┐
   │ Channel                    │ Purpose                    │
   ├────────────────────────────┼────────────────────────────┤
   │ matchmaking-requests       │ New matchmaking requests   │
   │ match-found               │ Successful matches         │
   │ match-cancelled           │ Cancelled matches          │
   │ match-timeout             │ Timed out matches          │
   │ game-events:{sessionId}   │ Game-specific events       │
   └─────────────────────────────────────────────────────────┘

3. REDIS OPERATIONS FLOW
   Write Operations:
   ┌─────────────────────────────────────────────────────────┐
   │ SET    → Store game state, user sessions               │
   │ ZADD   → Add player to matchmaking queue               │
   │ SETEX  → Store with TTL (turn timers, temp data)      │
   │ PUBLISH→ Send message to pub/sub channel              │
   │ MULTI  → Atomic transactions for complex operations   │
   └─────────────────────────────────────────────────────────┘

   Read Operations:
   ┌─────────────────────────────────────────────────────────┐
   │ GET    → Retrieve game state, user data               │
   │ ZRANGE → Get players from queue by score/time         │
   │ EXISTS → Check if key exists (session active?)        │
   │ TTL    → Check remaining time on keys                 │
   │ SUBSCRIBE → Listen to pub/sub channels               │
   └─────────────────────────────────────────────────────────┘

📡 PUB/SUB MESSAGING SYSTEM
═══════════════════════════

1. GOOGLE CLOUD PUB/SUB INTEGRATION
   ┌─────────────────┐    Publish    ┌─────────────────┐
   │ MatchmakingService │ ──────────► │ Pub/Sub Topic   │
   │                 │              │ (matchmaking-   │
   │                 │              │  requests)      │
   └─────────────────┘              └─────────────────┘
                                           │
                                           │ Message
                                           ▼
   ┌─────────────────┐   Subscribe   ┌─────────────────┐
   │ MatchmakingWorker │ ◄──────────── │ Pub/Sub Sub     │
   │ (Multiple       │              │ (matchmaking-   │
   │  instances)     │              │  worker)        │
   └─────────────────┘              └─────────────────┘

2. MESSAGE FLOW PATTERN
   Publisher:
   ┌─────────────────────────────────────────────────────────┐
   │ 1. Player requests match                                │
   │ 2. Validate request                                     │
   │ 3. Add to Redis queue                                   │
   │ 4. Publish to Pub/Sub topic                            │
   │ 5. Return acknowledgment                                │
   └─────────────────────────────────────────────────────────┘

   Subscriber:
   ┌─────────────────────────────────────────────────────────┐
   │ 1. Receive message from subscription                    │
   │ 2. Parse matchmaking request                            │
   │ 3. Find compatible players in Redis                     │
   │ 4. Atomic reservation of players                        │
   │ 5. Create game session                                  │
   │ 6. Publish match-found notification                     │
   └─────────────────────────────────────────────────────────┘

⏱️ PING/PONG & HEARTBEAT MECHANISMS
═══════════════════════════════════

1. SOCKET.IO HEARTBEAT
   Client ◄──────────────────────────► Server
     │                                   │
     │ ← ping (every 25s)                │
     │ pong →                            │
     │                                   │
     │ ← ping                            │
     │ (no response)                     │
     │                                   │
     │ ← disconnect event                │
     │   reason: 'ping timeout'          │

2. REDIS HEALTH CHECK
   Application ◄──────────────────────► Redis
     │                                   │
     │ PING →                            │
     │ ← PONG                            │
     │                                   │
     │ PING → (timeout)                  │
     │ ← (no response)                   │
     │                                   │
     │ Set redisAvailable = false        │

3. TURN TIMER HEARTBEAT
   ┌─────────────────────────────────────────────────────────┐
   │ 1. Player's turn starts                                │
   │ 2. Set Redis key with TTL: session:id:turn_timer       │
   │ 3. Start local setTimeout for auto-pass                │
   │ 4. Player makes move → Clear timer                     │
   │ 5. OR timeout → Auto-pass turn                         │
   └─────────────────────────────────────────────────────────┘

🎮 COMPLETE MATCHMAKING FLOW
════════════════════════════

Step 1: Player Requests Match
┌─────────────┐
│   Player    │ ──── find_match ────► ┌─────────────┐
│   Client    │                      │   Server    │
└─────────────┘                      └─────────────┘
                                           │
                                           ▼
                                    ┌─────────────┐
                                    │ Validate    │
                                    │ Request     │
                                    └─────────────┘
                                           │
                                           ▼
Step 2: Queue & Publish                ┌─────────────┐
                                    │ Add to      │
                                    │ Redis Queue │
                                    └─────────────┘
                                           │
                                           ▼
                                    ┌─────────────┐
                                    │ Publish to  │
                                    │ Pub/Sub     │
                                    └─────────────┘

Step 3: Worker Processing
┌─────────────┐    Subscribe    ┌─────────────┐
│ Matchmaking │ ◄────────────── │   Pub/Sub   │
│   Worker    │                │   Message   │
└─────────────┘                └─────────────┘
      │
      ▼
┌─────────────┐
│ Find Match  │
│ in Redis    │
└─────────────┘
      │
      ▼
┌─────────────┐
│ Atomic      │
│ Reservation │
└─────────────┘
      │
      ▼
┌─────────────┐
│ Create Game │
│ Session     │
└─────────────┘

Step 4: Notification
┌─────────────┐    Publish     ┌─────────────┐
│   Worker    │ ─────────────► │ match-found │
└─────────────┘               │   Topic     │
                              └─────────────┘
                                     │
                                     ▼
┌─────────────┐   Subscribe    ┌─────────────┐
│ Notification│ ◄────────────── │   Pub/Sub   │
│  Service    │                │ Subscription│
└─────────────┘                └─────────────┘
      │
      ▼
┌─────────────┐    WebSocket    ┌─────────────┐
│   Server    │ ──────────────► │   Players   │
│             │  match_found    │             │
└─────────────┘                └─────────────┘

🎯 GAME STATE SYNCHRONIZATION
═════════════════════════════

Real-time Game Action Flow:
┌─────────────┐                ┌─────────────┐
│  Player A   │ ─── action ──► │   Server    │
└─────────────┘                └─────────────┘
                                     │
                                     ▼
                              ┌─────────────┐
                              │ Load State  │
                              │ from Redis  │
                              └─────────────┘
                                     │
                                     ▼
                              ┌─────────────┐
                              │ Process via │
                              │ Game Engine │
                              └─────────────┘
                                     │
                                     ▼
                              ┌─────────────┐
                              │ Save New    │
                              │ State       │
                              └─────────────┘
                                     │
                                     ▼
                              ┌─────────────┐
                              │ Broadcast   │
                              │ to All      │
                              │ Players     │
                              └─────────────┘
                                     │
                    ┌────────────────┼────────────────┐
                    ▼                ▼                ▼
            ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
            │  Player A   │  │  Player B   │  │ Spectators  │
            │  (Updated)  │  │  (Updated)  │  │  (Updated)  │
            └─────────────┘  └─────────────┘  └─────────────┘

State Persistence Strategy:
┌─────────────────────────────────────────────────────────┐
│ Redis (Fast Access)     │ PostgreSQL (Persistence)     │
├─────────────────────────┼─────────────────────────────────┤
│ • Current game state    │ • Game session metadata      │
│ • Turn timers          │ • Match history               │
│ • Temporary data       │ • Player statistics           │
│ • Cache with TTL       │ • Permanent records           │
└─────────────────────────────────────────────────────────┘

🔄 POLLING vs WEBSOCKETS vs PUB/SUB
═══════════════════════════════════

Traditional Polling (❌ Not Used):
Client ──── "Any updates?" ────► Server
       ◄─── "No changes" ──────
       ──── "Any updates?" ────►
       ◄─── "No changes" ──────
       ──── "Any updates?" ────►
       ◄─── "Yes! New data" ────

WebSockets (✅ Real-time UI):
Client ◄────── Persistent ──────► Server
       ◄─── Instant Updates ────
       ──── User Actions ──────►
       ◄─── State Changes ──────

Pub/Sub (✅ Service Communication):
Service A ──── Message ────► Topic ────► Service B
                            │
                            └────► Service C
                            │
                            └────► Service D

⚡ PERFORMANCE OPTIMIZATIONS
═══════════════════════════

1. Connection Pooling:
   ┌─────────────────────────────────────────────────────────┐
   │ • Redis: Connection pool with keepAlive                │
   │ • PostgreSQL: Connection pool with max connections     │
   │ • Socket.IO: Room-based message targeting             │
   └─────────────────────────────────────────────────────────┘

2. Caching Strategy:
   ┌─────────────────────────────────────────────────────────┐
   │ • Game state: Redis with TTL                          │
   │ • Static data: Memory cache with periodic refresh      │
   │ • User sessions: Redis with sliding expiration        │
   └─────────────────────────────────────────────────────────┘

3. Message Optimization:
   ┌─────────────────────────────────────────────────────────┐
   │ • Delta updates: Only send changed data               │
   │ • Compression: gzip for large payloads                │
   │ • Batching: Group multiple updates                    │
   └─────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════
🎯 This architecture provides:
• Sub-second real-time updates via WebSockets
• Distributed scalability via Pub/Sub
• High availability via Redis clustering
• Atomic operations preventing race conditions
• Automatic failover and reconnection handling
═══════════════════════════════════════════════════════════════════
